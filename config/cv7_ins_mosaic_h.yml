/**/microstrain_inertial_driver:
  ros__parameters:
    # This can be set by passing an var to the launch file
    port     : /dev/microstrain_main
    baudrate : 115200
    set_baud : True

    # Disable the transform from the mount to frame id transform as it should be handled from a URDF file and robot_description
    publish_mount_to_frame_id_transform : False

    # This will cause the node to convert any NED measurements to ENU
    # This will also cause the node to convert any vehicle frame measurements to the ROS definition of a vehicle frame
    use_enu_frame : True

    # Configure some frame IDs
    frame_id          : cv7_ins_link  # Frame ID of all of the filter messages. Represents the location of the Cv7-INS in the tf tree
    map_frame_id      : map           # Frame ID of the global tangent plane.
    earth_frame_id    : earth         # Frame ID of the global frame
    target_frame_id   : base_link     # Frame ID that we will publish a transform to.

    # We will use relative transform mode, meaning that we will publish the following transforms from this node
    #   earth_frame_id -> map_frame_id
    #   map_frame_id -> target_frame_id
    # This helps ROS standard tools consume and display position information produced by the device.
    tf_mode: 2

    # This configuration will ensure that the driver publishes position relative to a global tangent plane
    # The origin of the tangent plane will be represented in the tf tree by map_frame_id, and will be the location where the filter first enters full nav.
    # If you want a constant position for the global tangent plane, see the documentation below
    #     Reference frame =
    #         1 - Relative ECEF position
    #         2 - Relative LLH position
    #
    #     Source =
    #         0 - Position will be reported relative to the base station. filter_relative_position_ref will be ignored
    #         1 - Position will be reported relative to filter_relative_position_ref
    #         2 - Position will be reported relative to the first position reported by the device after it enters full nav. filter_relative_position_ref will be ignored
    #         3 - We will wait for a transform to be made available between earth_frame_id and map_frame_id and use that as the relative position reference. filter_relative_position_ref will be ignored
    #
    #     Reference position - Units provided by reference frame (ECEF - meters, LLH - deg, deg, meters)
    filter_relative_position_config : True
    filter_relative_position_source : 2
    filter_relative_position_frame  : 2
    filter_relative_position_ref    : [0.0, 0.0, 0.0]

    # (GQ7 only) Filter Initialization control
    #     Auto-Heading alignment selector (note this is a bitfield, you can use more than 1 source) =
    #         Bit 0 - Dual-antenna GNSS
    #         Bit 1 - GNSS kinematic (requires motion, e.g. a GNSS velocity)
    #         Bit 2 - Magnetometer
    #         Bit 3 - External Heading (first valid external heading will be used to initialize the filter)
    # This sets the heading alignment to use only the external heading. Important to sub to /ext_heading_enu 
    filter_auto_heading_alignment_selector : 8

    # Setup some aiding options.
    filter_enable_gnss_pos_vel_aiding : True
    filter_enable_external_heading_aiding : True

    # This example shows a very basic setup with no PPS sync, so the PPS will be generated by the device's oscillator for drift constaint
    filter_pps_source : 4

    # Disable the filter declination source. This is required to get the node to start, and isn't doing anything special
    filter_declination_source : 1

    # For this use case, we will not publish any IMU data
    imu_data_rate : 0

    # The CV7-INS does not have any onboard GNSS receivers, so we would not be able to publish this data either way.
    # Global position data can be seen in the filter publishers configured below
    gnss1_llh_position_data_rate   : 0
    gnss1_velocity_data_rate       : 0
    gnss1_odometry_earth_data_rate : 0
    gnss2_llh_position_data_rate   : 0
    gnss2_velocity_data_rate       : 0
    gnss2_odometry_earth_data_rate : 0

    # We will publish the global position in both ECEF and LLH for this example
    # Also publish the human readable message which can be echoed from the command line
    filter_human_readable_status_data_rate : 1
    filter_llh_position_data_rate          : 50
    filter_odometry_earth_data_rate        : 50
    filter_odometry_map_data_rate          : 50

    # Subscribe to external aiding messages.
    # For this example we are subscribing to external GNSS position and velocity
    subscribe_ext_fix     : True
    subscribe_ext_vel_enu : True
    subscribe_ext_heading_enu : True


/**/ntrip_client:
  ros__parameters:
    # These can be set by passing args to the launch file
    host       : $(var ntrip_host)
    port       : $(var ntrip_port)
    mountpoint : $(var ntrip_mountpoint)

    # For this example, we will always assume that we are going to authenticate
    authenticate : true
    username : $(var ntrip_username)
    password : $(var ntrip_password)

    # If your NTRIP caster uses port 443 or 2102, you should probably set this to true in order to connect over HTTPS
    ssl : $(var ntrip_ssl false)

    # Since the RTCM will be coming from the RTK base station whose position may be the map frame, set the frame id to map
    rtcm_frame_id : "map"

    # Use the smaller RTCM message option
    rtcm_message_package : "rtcm_msgs"

    # Make sure that we can accept longer NMEA sentences
    nmea_max_length: 128

/**/septentrio_gnss_driver:
  ros__parameters:
    device: tcp://192.168.3.1:28784
    serial: "/dev/serial/by-id/usb-Septentrio_Septentrio_USB_Device_3815305-if02"
    baudrate: 921600
    rx_serial_port: USB1 #TODO check ports
    hw_flow_control: "off"

    stream_device:
      tcp:
        ip_server: ""
        port: 0        
      udp:
        ip_server: ""
        port: 0
        unicast_ip: ""

    configure_rx: true

    custom_commands_file: ""  

    osnma:
      mode: "off"
      ntp_server: ""
      keep_open: true

    frame_id: gnss

    imu_frame_id: imu

    poi_frame_id: base_link

    vsm_frame_id: vsm

    aux1_frame_id: aux1

    vehicle_frame_id: base_link

    local_frame_id: odom

    insert_local_frame: false

    get_spatial_config_from_tf: false

    lock_utm_zone: true

    use_ros_axis_orientation: true

    receiver_type: gnss    

    multi_antenna: true

    datum: Default

    poi_to_arp:
      delta_e: 0.0
      delta_n: 0.0
      delta_u: 0.0

    att_offset:
      heading: 0.0
      pitch: 0.0
      
    ant_type: "Unknown"
    ant_serial_nr: "Unknown"
    ant_aux1_type: "Unknown"
    ant_aux1_serial_nr: "Unknown"

    polling_period:
      pvt: 100
      rest: 500

    # time
    use_gnss_time: false
    ntp_server: true
    ptp_server_clock: false
    latency_compensation: true

    # RTK
    rtk_settings:  
      ntrip_1:
        id: ""
        caster: ""
        caster_port: 2101
        username: ""
        password: ""
        mountpoint: ""
        version: "v2"
        tls: false
        fingerprint: ""
        rtk_standard: "auto"
        send_gga: "auto"
        keep_open: true
      ip_server_1:
        id: ""
        port: 0
        rtk_standard: "auto"
        send_gga: "auto"
        keep_open: true
      serial_1:
        port: ""
        baud_rate: 115200
        rtk_standard: "auto"
        send_gga: "auto"
        keep_open: true

    publish:
      # For both GNSS and INS Rxs
      auto_publish: false
      publish_only_valid: false
      navsatfix: false
      gpsfix: true
      gpgga: false
      gprmc: false
      gpst: false
      measepoch: false
      pvtcartesian: false
      pvtgeodetic: true
      basevectorcart: false
      basevectorgeod: false
      poscovcartesian: false
      poscovgeodetic: true
      velcovcartesian: false
      velcovgeodetic: true
      atteuler: true
      attcoveuler: true
      pose: false
      twist: false
      diagnostics: false
      aimplusstatus: true
      galauthstatus: false
      # For GNSS Rx only
      gpgsa: false
      gpgsv: false
      # For INS Rx only
      insnavcart: false
      insnavgeod: false
      extsensormeas: false
      imusetup: false
      velsensorsetup: false
      exteventinsnavcart: false
      exteventinsnavgeod: false
      imu: false
      localization: false
      tf: false
      
    # INS-Specific Parameters

    ins_spatial_config:
      imu_orientation:
        theta_x: 0.0
        theta_y: 0.0
        theta_z: 0.0
      poi_to_imu:
        delta_x: 0.0
        delta_y: 0.0
        delta_z: 0.0
      ant_lever_arm:
        x: 0.0
        y: 0.0
        z: 0.0
      vsm_lever_arm:
        vsm_x: 0.0
        vsm_y: 0.0
        vsm_z: 0.0

    ins_initial_heading: auto

    ins_std_dev_mask:
      att_std_dev: 5.0
      pos_std_dev: 10.0

    ins_use_poi: false

    ins_vsm:
      ros:
        source: ""
        config: [false, false, false]
        variances_by_parameter: false
        variances: [0.0, 0.0, 0.0]
      ip_server:
        id: ""
        port: 0
        keep_open: true
      serial:
        port: ""
        baud_rate: 115200
        keep_open: true

    # logger

    activate_debug_log: false
